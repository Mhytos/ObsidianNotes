___
# Kompetenz
Ich kenne die Grundlagen des Programmierens, deren Herkunft, ihre Voraussetzungen und kann mit diesem Wissen Probleme verstehen und Lösungen dafür entwickeln

[[Cheat-Sheet|CheatSheet for exam about this]]
[[Analysing Problems|Theory Problem/Solution space]]
[[Datatypes|Theory Data Types]]
[[Functions|Theory Functions]]
[[User Stories|Theory User Storys]] (Problem Space stuff)

## 1. Problemstellungen erfassen, strukturierte Lösungsansätze entwickeln und für Aussenstehende formulieren
 [[Analysing Problems|Theroy]] we had during lessons

### 1.1 Problem- und Lösungsraum

Unter Problemraum versteht man das Verständnis des Problems und dessen Kontext. Hier geht es noch nicht darum, potentielle Lösungsansätze zu suchen, sondern und das Verstehen des vorliegenden Problems und dem "Ist-Stand". 
Man soll verstehen, was erreicht werden soll

Unter Lösungsraum versteht man das zusammentragen möglicher Ideen für die Problemlösung.
In einem zweiten Schritt wird aus den gesammelten Ideen ein Prototyp entwickelt, die Ideen werden konkretisiert. Es geht nicht um die Vollendung dieses Prototypen, sondern um eine Veranschaulichung.
In einem dritten Schritt, der Test-Phase werden die Ideen wirklich getestet. Mögliche Mängel und Probleme werden klar, und mit diesem Wissen kann man auch neue Ideen sammeln und Prototypen erstellen

>TL;DR: Problemraum steht für das Erfassen des Problems und dessen Verständnis | Lösungsraum für das wirkliche bearbeiten dieses Problems

### 1.2 Anforderungen Lösungsfrei identifizieren + Instrumente
_No Patrick, Mayonnaise is not an instrument_

Es geht um das Darstellen/ Aufzeigen von Anforderungen, ohne sich dabei mit dem "How" zu beschäftigen. 
Hierfür nutzt man am besten (respektive es wird erwartet) graphische Darstellungen wie ein Activity-Digramm. Man überlegt sich dabei nur was in welcher Reihenfolge geschehen soll, ohne auch nur daran zu denken, wie das funktionieren würde.
Es gibt 3 Stufen:
- einen graphisch beschriebenen Ablauf nachvollziehen
- selbst einen Programmablauf graphisch darstellen
- einen beschrieben Ablauf zu einem Programmablauf überführen und graphisch darstellen

>TL;DR: Ich kann, ohne das "Wie mache ich das" aufzeigen (graphisch), was ein dProgramm erfüllen muss und mit welchem Ablauf dies geschehen muss

### 1.3 Gründe Trennung Problem- und Lösungsraum

Wie [[M319 Applikationen entwerfen und implementieren#1.1 Problem- und Lösungsraum |hier]] erklärt teilen wir die Lösungsfindung auf in Problem- und Lösungsraum. Dies hat folgende Gründe/ Vorteile:
- Wir beschäftigen uns erst dann mit der implementation einer Lösung, wenn wir das Problem und dessen Kontext verstehen
- Wir finden mehr Ansätze, welche eventuell besser sind als unser erster, da wir Ideen sammeln und diese mit Prototypen bauen = Innovationsgewinn
- Wir verbeissen und nicht auf einen Ansatz
- Wir können bei Problemen auch auf andere Prototypen zurückfallen

>TL;DR: Wenn wir erst das Problem verstehen und erst dann beginnen, nach einer Lösung zu suchen arbeiten wir strukturierter und sparen uns Zeit

## 2. Visuelle Darstellung für das Programm

Hier geht es darum, ein Programm mit bestimmten Notationen darzustellen, also den Ablauf. 
Beispiele hierfür sind PAP, Struktogramm und Activity

Auch müssen wir den Zweck von Modellen und Diagrammen als Besprechungs- und Umsetzungsgrundlage kennen; heisst so viel wie wir wissen, das solche Darstellungen nützlich sind, um ohne eine Lösung über das Programm zu reden und das wir diese Darstellung dann als Grundlage für unsere praktische Umsetzung nutzen sollen


## 3. Aufgrund Vorgabe erforderliche Daten Ableiten

Also wir müssen wissen, wann zB ein Input oder Output geschieht, wann eine Verarbeitung von Daten geschieht und was die jeweiligen Datentypen sind.

- primitive und komplexe Datentypen
- boolean, string, array, int etc

Auch sollen wir die Funktionsweise eines Programms nach dem EVA Prinzip kennen
-> Eingabe Verarbeitung Ausgabe


## 4. Implementieren einer Applikation

>TL;DR Wir müssen eine Applikation erstellen können, wissen wie wir überprüfen ob alles korrekt läuft (log, breakpoints), Funktionen bauen + aufrufen können



## 5. Codekonventionen einhalten

>TL;DR wir sind über Sinn und Zweck von Konventionen informiert, kommentieren den Code und achten auf Wartbarkeit


## 6. Mit Fehlern umgehen

>TL;DR Wir können Debuggen

